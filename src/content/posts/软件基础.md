---
title: '软件基础：形式验证'
description: '一篇关于形式验证、Coq 安装和配置的入门指南，涵盖了 opam 和 VsCoq 的详细步骤。'
pubDate: 2025-07-30
tags: ['形式验证', 'Coq',  '教程', '环境配置']
author: 'Ating'
heroImage: 'software-found.webp'
ogImage: 'software-found.webp'
heroImageAspectRatio: '16/9'
recommend: true
---

形式验证是使用数学方法严格证明程序或系统正确性的技术。不同于测试（只能发现存在的错误），形式验证可以证明错误的不存在。

形式验证的目标是，将一段程序的功能用另一段程序表达，并且再用另一段程序来表示该程序符合给定的功能要求。

## Coq安装

Coq 提供了Linux、Windows和MacOS 在内的多系统安装。但是由于博主电脑问题或者其他一些原因，并没有成功安装其Windows环境，只能想办法在WSL2中，即Linux中使用COQ。
也幸亏之前有过WSL2+VsCode经验，不然又少不了一番折腾。

### 安装opam

Linux 和MacOs 可以使用 opam 官网提供的脚本一键安装。

```bash title='Shell Command'
bash -c "sh <(curl -fsSL https://opam.ocaml.org/install.sh)"
```

注意： 脚本会将 opam 默认安装到 `/usr/local/bin`，如不修改请确保当前用户该路径有读写权限`(sudo)`。

安装完成后可以使用下面命令确认是否安装成功。如果成功将返回 opam的版本号，为确保Coq 安装成功，请安装最新版 opam。

```bash title='Shell Command'
opam --version
```

安装成功后需要执行下面命令 初始化 opam 状态：

```bash title='Shell Command'
opam init
```

至此 opam 安装配置完成。

### 使用 opam 安装 Coq

本小节内容亦可访问 :link[官方安装指南]{id=https://coq.inria.fr/opam-using.html}。 

首先确保 opam 安装成功并初始化，接下来可以使用下面命令自动安装，由于 Coq 需要从源码编译所以安装时间较长：

```bash title='Shell Command'
opam pin add coq 8.20.0
```

注意：Coq 最新版本可能已更新，如果想查看最近版本请访问 :link[Coq官网]{id=https://coq.inria.fr/} 或者其 :link[github仓库]{id=https://github.com/coq/coq} 

以上述命令安装 Coq 不会自动更新，若更新请执行：

```bash title='Shell Command'
opam pin add coq <版本号>
```

使用下面命令可以查看 Coq 是否被正确安装：

```bash title='Shell Command'
coqc --version
```
<!-- :link[Coq官网]{id=https://coq.inria.fr/} 或者其 :link[github仓库]{id=https://github.com/coq/coq} -->
### 配置 VsCoq
首先在 vscode 中安装扩展 VsCoq。接下来按照 :link[插件说明页]{id=https://marketplace.visualstudio.com} 
的说明，依次运行两个下载命令：

```bash title='Shell Command'
opam pin add coq 8.18.0
opam install vscoq-language-server
```

这会在 ubuntu 上安装 language server，接下来为了让 vscode 找到这个 server，你需要运行

```bash title='Shell Command'
which vscoqtop
```

> [!caution]
> **注意**
>
> 如果此时没有输出（即失败），可能是没有刷新。运行
> ```bash title='Shell Command'
> eval $(opam env)
> ```

此时你将得到一个类似于
```bash title='Shell Command'
`/home/$USERNAME$/.opam/default/bin/vscoqtop`
```
的输出，将其**完整地复制下来**，填入 VsCoq 的 Extension Setting 中，`VsCoq: Path` 的值。

>有人在 Windows 下配环境变量配习惯了，把路径复制到 `../bin` 就停了。但是此时必须要完整地复制全部内容。

## COQ语法介绍

在浏览软件基础这本书时，发觉它对入门者的照顾并不是特别友好，因此，关于Coq的语法规则，我使用Cluade大模型来进行一步步的讲解。
### 1. 基本定义和声明
#### 1.1 定义常量
使用 Definition 来定义常量或函数。
```coq
Definition pi := 3.14.
Check pi.  (* 输出: pi : R *)
```
#### 1.2 定义函数
以下是一个定义简单加法函数的例子：
```coq
Definition add (a b : nat) : nat := a + b.
Check add.
(* 输出: add : nat -> nat -> nat *)
```
### 2. 数据类型
#### 2.1 自然数（nat）
Coq 内置了自然数类型 nat，并提供了相关操作。
```coq
Check 0.  (* 输出: 0 : nat *)
Check 1.  (* 输出: 1 : nat *)
```
#### 2.2 布尔型（bool）
布尔型在 Coq 中也很常用。
```coq
Check true.  (* 输出: true : bool *)
Check false. (* 输出: false : bool *)
```
#### 3. 归纳类型
你可以定义自己的数据结构，例如列表。
```coq
Inductive my_list (A : Type) : Type :=
  | nil : my_list A
  | cons : A -> my_list A -> my_list A.
```
### 4. 函数定义与模式匹配
#### 4.1 定义函数
使用 Fixpoint 定义递归函数。以下是一个计算列表长度的例子：
```coq
Fixpoint my_length {A : Type} (l : my_list A) : nat :=
  match l with
  | nil _ => 0
  | cons _ _ l' => 1 + my_length l'
  end.
  ```
### 5. 证明结构
#### 5.1 声明定理
使用 Theorem 来声明一个新的定理。
```coq
Theorem zero_plus : forall n : nat, 0 + n = n.
Proof.
  (* 证明将在这里进行 *)
Qed.
```
#### 5.2 使用策略
以下是使用策略证明加法的性质：
```coq
Theorem zero_plus : forall n : nat, 0 + n = n.
Proof.
  intro n.      (* 引入变量 n *)
  simpl.       (* 简化表达式 *)
  reflexivity. (* 证明两边相等 *)
Qed.
```
#### 5.3 归纳法证明
归纳法证明的基本结构如下：
```coq
Theorem plus_0_r : forall n : nat, n + 0 = n.
Proof.
  intro n.
  (* 使用归纳法 *)
  induction n as [| n' IHn'].
  - simpl. reflexivity.  (* 基础情况 *)
  - simpl. rewrite -> IHn'. reflexivity.  (* 归纳步骤 *)
Qed.
```
### 6. 条件语句和循环
Coq 使用模式匹配来定义条件和处理逻辑。
```coq
Definition is_zero (n : nat) : bool :=
  match n with
  | 0 => true
  | _ => false
  end.
  ```
### 7. 逻辑运算
Coq 提供了基本的逻辑运算，例如与（and）、或（or）、非（not）。

#### 7.1 逻辑与
```coq
Definition and_example (p q : Prop) : Prop := p /\ q.
```
#### 7.2 逻辑或
```coq
Definition or_example (p q : Prop) : Prop := p \/ q.
```
#### 7.3 逻辑非

```coq
Definition not_example (p : Prop) : Prop := ~p.
```
### 8. 变量和类型
#### 8.1 类型声明
你可以声明变量和其类型：

```coq
Definition x : nat := 5.
Check x.  (* 输出: x : nat *)
```
#### 9. 注释
Coq 允许使用 (* ... *) 进行注释：

> (* 这是一个注释 *)

### 一周七日

#### 定义类型

```js title='one.v' collapse={1-10, 20-31} showLineNumbers
(*
这段Coq代码定义了一个新的归纳类型（Inductive Type），名为 day。
可以这样理解：
Inductive day : Type: 这部分声明了我们要创建一个名为 day 的新类型。Inductive 关键字表示这个类型是通过列举其所有可能的构造函数（constructor）来定义的。: Type 表示 day 本身是一个类型。
:=: 这是定义操作符，意思是“被定义为”。
| monday | tuesday ... | sunday: 这一长串由 | 分隔的列表是 day 类型的构造函数。每一个构造函数都是 day 类型的一个唯一、离散的值。
简单来说，这段代码是在创建一个枚举类型，就像在其他编程语言中一样。 它创建了一个名为 day 的新类型，这个类型的变量只能取 monday, tuesday, wednesday, thursday, friday, saturday, sunday 这七个值中的一个。
*)


Inductive day : Type :=
| monday 
| tuesday 
| wednesday 
| thursday 
| friday 
| saturday 
| sunday.

(*
match d with ... end:

这是一个模式匹配表达式，是Coq（以及许多函数式编程语言）中非常核心和强大的功能。
它的作用是检查变量 d 的具体值，并根据不同的值执行不同的代码分支。
你可以把它看作是其他语言中 switch-case 语句的更强大版本。
| monday => tuesday:

这是一个匹配分支。| 分隔了不同的情况。
它表示：“如果 d 的值是 monday，
那么 => 整个表达式的结果就是 tuesday”。
*)
Definition next_weekday (d : day) : day :=
match d with
| monday => tuesday
| tuesday => wednesday 
| wednesday => thursday 
| thursday => friday 
| friday => monday 
| saturday => monday 
| sunday => monday 
end.

(* 测试：计算 next_weekday friday 的结果（应返回 monday） *)
Compute (next_weekday friday).  (* 输出：monday : day *)

(* 
   定义一个测试用例命题：
   "连续两次对 saturday 调用 next_weekday 的结果应等于 tuesday"
   解释：
   1. 第一次 next_weekday saturday → monday
   2. 第二次 next_weekday monday → tuesday
*)
Example test_next_weekday:
  (next_weekday (next_weekday saturday)) = tuesday.

(* 证明过程：
   - simpl：化简表达式（计算具体值）
   - reflexivity：检查等式两边是否相同
   - Qed：完成证明
*)
Proof. 
  simpl.       (* 展开计算：next_weekday saturday → monday 
                       然后 next_weekday monday → tuesday *)
  reflexivity. (* 验证 tuesday = tuesday *)
Qed.

(* 检查 test_next_weekday 的类型，确认它是一个已被证明的命题 *)
Check test_next_weekday.  (* 输出：test_next_weekday : ... = tuesday *)
```
如上所述，有了上面这个例子，之后的一些内容就可以看懂了，此处不再赘述。

#### 练习(✨) standard (nandb)

```coq title="nandb.v"
Definition nandb (b1:bool) (b2:bool) : bool :=
(*一开始不知道match可以匹配两个参数*)
  match b1, b2 with
  | true, true => false
  | _, _       => true
  end.

Example test_nandb1: (nandb true false) = true.
Proof. reflexivity. Qed.

Example test_nandb2: (nandb false false) = true.
Proof. reflexivity. Qed.

Example test_nandb3: (nandb false true) = true.
Proof. reflexivity. Qed.

Example test_nandb4: (nandb true true) = false.
Proof. reflexivity. Qed.
```
> [!caution] simpl 和 reflexivity 的简明总结
> ```markdown
># Coq 中的 `simpl` 和 `reflexivity` 总结
>
>## 1. 为什么例子不加 `simpl` 也能通过？
> - `reflexivity` 会自动进行隐式计算
> - 能直接处理像 `nandb` 这样的透明定义
> - 自动验证化简后的等式（如 `true = true`）
>
> ## 2. `simpl` 的作用
> | 功能 | 说明 |
> |------|------|
> | 显式化简 | 展开函数定义、计算 match 分支 |
> | 调试用途 | 观察中间计算步骤 |
> | 复杂表达式 | 需要分步计算时使用 |
>
> ## 3. 策略对比
> | 策略 | 功能 | 自动计算 |
> |------|------|---------|
> | `reflexivity` | 检查等式一致性 | 是 |
> | `simpl` | 仅进行表达式化简 | 否 |
>
> ## 4. 必须使用 `simpl` 的情况
> ```coq
> Example: (1 + 1) + (1 + 1) = 4.
> Proof.
>  simpl.      (* 必须显式化简 *)
>  reflexivity.
> Qed.
> 
> ```
#### 练习(✨) standard (andb3)

```coq title="and3.v"
Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool :=  
match b1,b2,b3 with
| true,true,true => true
| _,_,_ => false
end.

Example test_andb31: (andb3 true true true) = true. 
Proof. simpl. reflexivity. Qed. 
Example test_andb32: (andb3 false true true) = false. 
Proof. simpl. reflexivity. Qed.
Example test_andb33: (andb3 true false true) = false. 
Proof. simpl. reflexivity. Qed.
Example test_andb34: (andb3 true true false) = false. 
Proof. simpl. reflexivity. Qed. 
```
